# DIY simple package installer, backpack
# ======================================

BP_COMMAND=$1
BP_CATEGORY=$2
shift 2

LOCAL_PREFIX="$HOME/.bp"
LOCAL_BIN=$LOCAL_PREFIX/bin
LOCAL_PKG=$LOCAL_PREFIX/pkg
LOCAL_LIB=$LOCAL_PREFIX/lib
LOCAL_SRC=$LOCAL_PREFIX/src
LOCAL_LOG=$LOCAL_PREFIX/log
LOCAL_INC=$LOCAL_PREFIX/include
mkdir -p $LOCAL_BIN
mkdir -p $LOCAL_SRC
mkdir -p $LOCAL_LOG
mkdir -p $LOCAL_INC
mkdir -p $LOCAL_PKG
SELECTED_PKGS=$@
export PKG_CONFIG_PATH=$LOCAL_PREFIX/share/pkgconfig:$LOCAL_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH
#GNULIB_SRCDIR=$LOCAL_INC/gnulib
export LDFLAGS=-L$LOCAL_LIB $LDFLAGS
export CPPFLAGS=-I$LOCAL_INC $CPP_FLAGS
export CFLAGS=-I$LOCAL_INC $CFLAGS
export CXXFLAGS=-I$LOCAL_INC $CXXFLAGS

SKIP_CATEGORY=0
SKIP_PACKAGE=0

begin_skip() {
	SKIP_CATEGORY=1
}

end_skip() {
	SKIP_CATEGORY=0
}

not_selected() {
	[ "$SKIP_CATEGORY" -ne 0 ] || [ "$SKIP_PACKAGE" -ne 0 ]
}

category() {
	[ "$BP_CATEGORY" == "$1" ] && end_skip && return 0
	begin_skip
}

package() {
	SKIP_PACKAGE=0
	not_selected && return 0
	if [[ " $SELECTED_PKGS " =~ .*\ $1\ .* || -z "$SELECTED_PKGS" ]]; then
		SKIP_PACKAGE=0
		PKG_NAME=$1
		SRC_DEST=$LOCAL_SRC/$PKG_NAME
		BIN_DEST=$LOCAL_BIN/$PKG_NAME
	else
		SKIP_PACKAGE=1
	fi
}

download() {
	not_selected && return 0
	PKG_URL=$1
	printf "downloading %s from %s\n" $PKG_NAME $PKG_URL
	getfile $PKG_URL $LOCAL_PKG &> $LOCAL_LOG/$PKG_NAME.download
	printf "extracting %s\n" ${PKG_URL##*\/}
	bp_extract $PKG_URL &> $LOCAL_LOG/$PKG_NAME.extract
}

# getfile <src-url> <dst-dir>
getfile() {
	SRC_URL=$1
	DST_DIR=$2
	[ ! -x "$(which curl)" ] && [ ! -x "$(which wget)" ] \
		&& echo "Please install wget or curl." && exit 1
	# Extract the filename from url and append it to output path
	DST_PATH=$DST_DIR/${SRC_URL##*\/}
	[ -s $DST_PATH ] && return 0
	if [ -x "$(which curl)" ]; then
		curl -L $SRC_URL --output $DST_PATH
	else
		wget --no-check-certificate -P $DST_DIR $SRC_URL
	fi
#	[ "$(file $DST_PATH)" == *"compressed data"* ] && return 0
#	echo "$DST_PATH is not compressed data"
#	return 1
}

bp_extract() {
	ghetto_cut() {
		for i in $1; do echo $i; break; done
	}
	FNAME=${1##*\/}
	mkdir -p $SRC_DEST
	mkdir -p /tmp/bp
	cd /tmp/bp
	TARCMD="tar x "
	case $FNAME in
		*.tar)
			$TARCMD -f $LOCAL_PKG/$FNAME
			;;
		*.tar.gz)
			gunzip -c $LOCAL_PKG/$FNAME | $TARCMD
			;;
		*.tar.xz)
			xz -c $LOCAL_PKG/$FNAME | $TARCMD -J
			;;
		*.tar.bz2)
			bunzip2 -c $LOCAL_PKG/$FNAME | $TARCMD
			;;
		*)
			echo "Unknown extension: $FNAME"
			return 1
			;;
	esac
	# Assume a single directory was extracted, try to get its name
	NEW_DIR=$(ghetto_cut $(ls -t | grep -v "*.tar*"))
	[ -d "$PWD/$NEW_DIR" ] && mv $PWD/$NEW_DIR/* $SRC_DEST/
	cd $SRC_DEST
	rm -rf /tmp/bp
}

define() {
	not_selected && return 0
	[ "$1" != "$BP_COMMAND" ] && return 0
	shift
	[ "$1" == ":" ] && shift
	DELIM=,
	echo "$BP_COMMAND $PKG_NAME..."
	mkdir bp-build && cd bp-build
	while [ $# -gt 0 ]
	do
		printf "\t+$1 "
		local args
		local cmd
		local cmdname
		args=()
		case $1 in
			#TODO: instead of hard coding, check for leading "./" to append dir to
			config|configure)
				cmdname=$1
				cmd=$LOCAL_SRC/$PKG_NAME/$1
				shift
				args+=(--prefix=$LOCAL_PREFIX)
				;;
			make)
				cmdname=$1
				cmd=$1
				shift
				;;
			*)
				echo "Unrecognized build command '$1'"
				return 1
				;;
		esac
		while [ $# -gt 0 -a "$1" != "$DELIM" ]
		do
			printf " $1"
			args+=($1)
			shift
		done
		printf "\n"
		shift
		$cmd "${args[@]}" &> $LOCAL_LOG/$PKG_NAME.$cmdname
		ex=$?
		if [ $ex -ne 0 ]
		then
			printf "\tfailed with exit code $ex\n"
			echo "********************************"
			tail $LOCAL_LOG/$PKG_NAME.$cmdname
			echo "********************************"
			return $ex
		fi
	done
	printf "\tcompleted\n"
}

source $backpack_scripts/packages
