" Options {{{
" Always use UTF-8
set encoding=utf-8
scriptencoding utf-8
" Disable vi-compatible defaults
" Allow folding in files using {{{ and }}}
set foldenable
set foldmethod=marker
" No annoying sounds / flashes
set noerrorbells
" Allow files to customize settings on open
set modeline
" Characters used when list=on
set listchars=eol:$,tab:>\ ,extends:>,precedes:<,nbsp:+,trail:_
" Character used to mark wrapped lines
set showbreak==>\
" Copy the indentation from the previous line
set autoindent
" Short blink when typing matching parens
set showmatch
set matchtime=1
" Allow leaving modified buffers without saving
set hidden
" Try to keep windows similarly sized
set equalalways
set eadirection=both
" Don't show the active mode
set noshowmode
" Search as you're typing
set incsearch
set hlsearch
" Allow backspacing over everything
set backspace=indent,eol,start
" Enable the mouse
set mouse=a
" Set US English for spellcheck
set spelllang=en_us
" Always show statusbar
set laststatus=2
" Don't wrap lines by default
set nowrap
" Don't page output
set more
" Default to new windows appearing below current
set splitbelow
" Don't try to set the cursor
set guicursor=
" Preview window is small
"set previewheight=3
" CursorHold kicks in after 1/10 second
set updatetime=100
" Reduce screen artifacts by delaying redraw
set lazyredraw
" Show cmd in progress
set showcmd
" Recursive searching
set path+=**
" Tab completion menu
set wildmenu
" Don't scroll near borders, use an autocmd to do that
set scrolloff=0
set sidescrolloff=0
set sidescroll=80
" Allow windows to collapse completely
set winminwidth=1
set winminheight=1
set completeopt+=menuone,noinsert,preview,longest
" Default tab settings
set shiftwidth=4
set softtabstop=4
set expandtab
" Use line drawing char for vsp, spaces for folds
if has('nvim')
    set fillchars=vert:â”‚,fold:\ ,eob:\ ,diff:-
else " vim doesn't have the eob option
    set fillchars=vert:â”‚,fold:\ ,diff:-
endif
" Use filetype-based plugin and indent scripts
filetype plugin indent on
try
    colorscheme lyra
endtry
" }}}
" Functions {{{
" FIXME this should go somewhere else
let b:statuslime_right = has('nvim') ? 'N' : 'V'
func! SetStatusLime()
    if has('nvim')
        try
            let b:statuslime_left = neomake#statusline#get(bufnr('%'), {
                        \ 'use_highlights_with_defaults': 0,
                        \ 'format_running': 'Running {{running_job_names}}â€¦',
                        \ 'format_loclist_ok': 'âœ“',
                        \ 'format_loclist_issues': '%s',
                        \ 'format_quickfix_ok': '',
                        \ 'format_quickfix_issues': '%s',
                        \ 'format_loclist_type_W': '{{count}} warning(s) ',
                        \ 'format_loclist_type_E': '{{count}} error(s) ',
                        \ 'format_loclist_type_I': '{{count}} message(s) ',
                        \ })
        endtry
    endif
    return ''
endfunc

" Useful for debugging syntax highlighting
func! HiAtCur()
    let l:name = ''
    for id in synstack(line('.'), col('.'))
        let l:name = synIDattr(id, 'name')
        echo l:name
    endfor
    if l:name isnot# ''
        exec 'hi '.l:name
    endif
endfunc
nmap <leader>c :call HiAtCur()<cr>
" }}}
" Plugins {{{

if has('nvim')
    let g:helper_plug_path = $HOME.'/.config/nvim/repos'
else
    let g:helper_plug_path = $HOME.'/.vim/repos'
endif

call helper#begin()

call helper#plug('bfrg/vim-cpp-modern')
call helper#plug('ap/vim-buftabline')
call helper#plug('ekalinin/dockerfile.vim')
call helper#plug('google/vim-searchindex')
call helper#plug('guns/xterm-color-table.vim')
call helper#plug('junegunn/gv.vim')
call helper#plug('junegunn/vim-easy-align')
call helper#plug('machakann/vim-sandwich')
call helper#plug('mboughaba/i3config.vim')
call helper#plug('michaeljsmith/vim-indent-object')
call helper#plug('peterrincker/vim-argumentative')
call helper#plug('reedes/vim-litecorrect')
call helper#plug('rhysd/conflict-marker.vim')
call helper#plug('rhysd/git-messenger.vim')
call helper#plug('roxma/vim-paste-easy')
call helper#plug('sheerun/vim-polyglot')
call helper#plug('tbastos/vim-lua')
call helper#plug('thinca/vim-ref')
call helper#plug('tpope/vim-abolish')
call helper#plug('tpope/vim-commentary')
call helper#plug('tpope/vim-eunuch')
call helper#plug('tpope/vim-fugitive')
call helper#plug('tpope/vim-rsi')
call helper#plug('tpope/vim-sensible')
call helper#plug('tpope/vim-unimpaired')
call helper#plug('tpope/vim-vinegar')
call helper#plug('tpope/vim-apathy')
call helper#plug('tpope/vim-markdown')
call helper#plug('wellle/visual-split.vim')
call helper#plug('jvirtanen/vim-octave')
call helper#plug('mattboehm/vim-accordion')
call helper#plug('terryma/vim-multiple-cursors')
call helper#plug('romainl/vim-qf')
call helper#plug('ervandew/supertab')
call helper#plug('thaerkh/vim-indentguides')

if has('nvim') " IDE-style features for nvim
    call helper#plug('neomake/neomake')
    call helper#plug('chiel92/vim-autoformat')
    call helper#plug('prabirshrestha/async.vim')
    call helper#plug('prabirshrestha/vim-lsp')
else
    " Disable neomakelist on vim
    let g:loaded_neomakelist = v:true
endif

call helper#end()
" }}}
" Maps {{{
if has('terminal')
    " Navigate out of terminal mode more easily
    tnoremap <esc> <c-\><c-n>
    tnoremap <c-w> <c-\><c-n><c-w>
endif
" Quick reload of vimrc
nnoremap <leader>V :source $MYVIMRC<cr>
" Clear search with <C-L>
nnoremap <c-l> :noh<cr><c-l>

" Use ` as optional wincmd prefix
nnoremap ` <c-w>
nnoremap <c-w>` `

nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)

nmap <silent><leader>? <Plug>(helper-toggle)
noremap <silent><leader>g :GitMessenger<cr>

nmap ga <Plug>(EasyAlign)
vmap <Enter> <Plug>(EasyAlign)

nmap <buffer>]x <Plug>(conflict-marker-next-hunk)
nmap <buffer>[x <Plug>(conflict-marker-prev-hunk)

xmap <leader>p <Plug>(Visual-Split-SplitAbove)
xmap <leader>n <Plug>(Visual-Split-Resize)
nmap <leader>p <Plug>(Visual-Split-SplitAbove)
nmap <leader>n <Plug>(Visual-Split-Resize)

nnoremap <leader><pageup> :AccordionZoomOut<CR>
nnoremap <leader><pagedown> :AccordionZoomIn<CR>

nnoremap <c-w>2 :Accordion 2<CR>
nnoremap <c-w>3 :Accordion 3<CR>
nnoremap <c-w>4 :Accordion 4<CR>

" Ctrl+K to search for cursor text and show in quickfix
nnoremap <c-k> :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

" }}}
" Autocmds & Plugin Configuration {{{

"augroup vimrc_help
"    autocmd!
"    autocmd BufEnter *.txt if &buftype == 'help' | wincmd L | endif
"augroup END

let g:buftabline_indicators = 1
let g:buftabline_numbers = 0

let g:git_messenger_include_diff = v:true
let g:git_messenger_max_popup_height = 8

let g:conflict_marker_enable_mappings = 0

let g:formatterpath = [$HOME.'/.local/bin']

augroup vimrc
    autocmd!
    autocmd VimEnter * silent! AccordionAll 2 | IndentGuidesToggle
augroup END

if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --column
    set grepformat=%f:%l:%c%m
endif

let g:multi_cursor_use_default_mapping=0

let g:SuperTabContextTextMembersPatterns = ['\.', '>\?::', '->', ':', ' ']
let g:SuperTabDefaultCompletionType = 'context'
let g:SuperTabNoCompleteAfter = ['^ *', '\t']
if has('nvim')
    let g:SuperTabContextDefaultCompletionType = '<c-x><c-o>'
endif

let g:indentguides_spacechar = 'ðŸ®Œ'
let g:indentguides_tabchar = 'â–‘'
let g:indentguides_toggleListMode = v:false
let g:indentguides_firstlevel = v:true

" }}}
" Neovim IDE Setup {{{
if !has('nvim') | finish | endif

set termguicolors

call neomake#configure#automake({
            \ 'TextChanged': {},
            \ 'InsertLeave': {},
            \ 'BufWritePost': {'delay': 0},
            \ 'BufWinEnter': {},
            \}, 500)

let g:neomake_highlight_columns = 0
let g:neomake_makers_buffer_output = 0
let g:neomake_virtualtext_current_error = 0
let g:neomake_info_sign          = { 'text': 'â–·' }
let g:neomake_message_sign       = { 'text': 'â–¶' }
call neomake#signs#RedefineErrorSign({ 'text': 'â•³', 'texthl': 'Error' })
call neomake#signs#RedefineWarningSign({ 'text': 'âœ—', 'texthl': 'Error' })

" Don't report issues inside system headers
function PostprocessClangTidy(entry)
    try
        let l:fname = a:entry['filename']
    catch
        let l:fname = bufname(a:entry['bufnr'])
    endtry
    try
        if l:fname =~# '/usr/include'
            let a:entry['valid'] = -1
        endif
    endtry
endfunction

try
    let g:nproc = str2nr(system('nproc'))
catch
    let g:nproc = 1
endtry

let g:neomake_cpp_enabled_makers = executable('clang++') ?
            \ ['clangtidy'] : ['gcc']
call add(g:neomake_cpp_enabled_makers, 'cppcheck')
let g:neomake_cpp_clangtidy_maker = {
            \ 'exe': '/home/athresher/.local/share/clang/run-clang-tidy.py',
            \ 'args': [
            \       '-quiet',
            \       '-j', string(g:nproc),
            \       '-checks=-*,bugprone-*,cppcoreguidelines-*,'
            \           .'clang-analyzer*,hicpp-*,misc-*,modernize-*,mpi-*,'
            \           .'openmp-*,performance-*,readability-*,portability-*'
            \ ],
            \ 'postprocess': function('PostprocessClangTidy'),
            \ 'errorformat':
            \       '%E%f:%l:%c: fatal error: %m,' .
            \       '%E%f:%l:%c: error: %m,' .
            \       '%W%f:%l:%c: warning: %m,' .
            \       '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
            \       '%E%m'
            \}

let g:formatters_python = ['yapf']
let g:formatdef_yapf = '"yapf --style=\"$HOME/.style.yapf\""'
let s:lsp_map = {}
augroup NeovimIDE
    autocmd!
    " Autoformat on save
    autocmd BufWrite * silent! Autoformat
    if executable('clangd')
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'clangd',
                    \ 'cmd': {server_info->['clangd']},
                    \ 'whitelist': ['cpp', 'c']
                    \ })
        let s:lsp_map['c']   = 'clangd'
        let s:lsp_map['cpp'] = 'clangd'
    endif
    if executable('pyls')
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'pyls',
                    \ 'cmd': {server_info->['pyls']},
                    \ 'whitelist': ['python'],
                    \ })
        let s:lsp_map['python'] = 'pyls'
    endif
    if executable($HOME.'/.local/bin/bash-language-server')
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'bash-language-server',
                    \ 'cmd': {server_info->[$HOME.'/.local/bin/bash-language-server', 'start']},
                    \ 'whitelist': ['sh'],
                    \ })
        let s:lsp_map['sh'] = 'bls'
    endif
    if executable($HOME.'/.local/bin/docker-langserver')
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'docker-langserver',
                    \ 'cmd': {server_info->[$HOME.'/.local/bin/docker-langserver', '--stdio']},
                    \ 'whitelist': ['Dockerfile'],
                    \ })
        let s:lsp_map['Dockerfile'] = 'dls'
    endif
    if executable($HOME.'/.yarn/bin/vim-language-server')
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'vim-language-server',
                    \ 'cmd': {server_info->[$HOME.'/.yarn/bin/vim-language-server', '--stdio']},
                    \ 'whitelist': ['vim'],
                    \ })
        let s:lsp_map['vim'] = 'vls'
    endif
augroup END

let g:lsp_preview_doubletap    = v:false
let g:lsp_signs_enabled        = v:false
let g:lsp_virtual_text_enabled = v:false
let g:lsp_diagnostics_enabled  = v:false

function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    nmap <buffer> <leader>D <plug>(lsp-peek-definition)
    nmap <buffer> <leader>d <plug>(lsp-peek-declaration)
    nmap <buffer> <leader>R <plug>(lsp-rename)
    nmap <buffer> <leader>s <plug>(lsp-signature-help)
    nmap <buffer> <leader>r <plug>(lsp-references)
    nmap <buffer> <leader>h <plug>(lsp-hover)
    augroup lsp_enabled
        autocmd!
        autocmd CompleteDone * if pumvisible() == 0 | pclose | endif
    augroup END
    let b:statuslime_right = s:lsp_map[&filetype]
endfunction

augroup lsp_install
    autocmd!
    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END
" }}}
