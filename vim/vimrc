
" TODO: Find a better solution for tabs. Sleuth is fooled by
" clang-format's half-indentation of public/private
set shiftwidth=4
set softtabstop=4
set expandtab

" TODO: write a plugin that automatically sets window sizes

" Plugins {{{

" Keep track of plugins to auto-generate help menu
let g:plugin_master_list = []
let g:plugin_help_list = []
func! s:plug(repo, has_help)
    try
        call plug#(a:repo)
        let g:plugin_master_list = g:plugin_master_list + [a:repo]
        if a:has_help != 0
            let g:plugin_help_list = g:plugin_help_list + [a:repo]
        endif
    catch
        echoerr 'Failed to load plugin "'.a:repo.'"'
    endtry
endfunc
let g:plugin_help_menu = 1

if has('nvim')
    let g:plugin_path = '~/.config/nvim/repos'
else
    let g:plugin_path = '~/.vim/repos'
endif

try
    call plug#begin(g:plugin_path)

    " TODO: look at official yapf plugin
    "call s:plug('mizuchi/stl-syntax')
    "call s:plug('unblevable/quick-scope') " TODO: see if this caused slowdown
    "call s:plug('vim-scripts/errormarker.vim') " TODO: set up cmake in vim
    call s:plug('ap/vim-buftabline', 1)
    call s:plug('bfrg/vim-cpp-modern', 0)
    call s:plug('google/vim-searchindex', 1)
    call s:plug('junegunn/vim-easy-align', 1)
    call s:plug('machakann/vim-sandwich', 1)
    call s:plug('mboughaba/i3config.vim', 0)
    call s:plug('peterrincker/vim-argumentative', 1)
    call s:plug('reedes/vim-litecorrect', 0)
    call s:plug('rhysd/git-messenger.vim', 1)
    call s:plug('sheerun/vim-polyglot', 0)
    "call s:plug('shougo/echodoc', 1) " TODO: Figure out how this works, try disabling funcsig
    call s:plug('skywind3000/quickmenu.vim', 0)
    call s:plug('tbastos/vim-lua', 0)
    call s:plug('thinca/vim-ref', 1)
    call s:plug('tpope/vim-abolish', 1)
    call s:plug('tpope/vim-commentary', 1)
    call s:plug('tpope/vim-eunuch', 1)
    call s:plug('tpope/vim-fugitive', 1)
    call s:plug('tpope/vim-rsi', 1)
    call s:plug('tpope/vim-sensible', 0)
    call s:plug('tpope/vim-unimpaired', 1)
    "call s:plug('tweekmonster/braceless.vim', 1)
    call s:plug('yggdroot/indentline', 1)
    call s:plug('lifepillar/vim-mucomplete', 1)

    if has('nvim')
        Plug 'neovim/nvim-lsp'
    endif

    call plug#end()
catch
    echom "vim-plug is missing or broken"
endtry

" }}}

" Options {{{
" Disable vi-compatible defaults
set nocompatible
" Allow folding in files using {{{ and }}}
set foldenable
set foldmethod=marker
" Always use UTF-8
set encoding=utf-8
scriptencoding utf-8
" No annoying sounds / flashes
set noerrorbells
" Allow files to customize settings on open
set modeline
" Characters used when list=on
set listchars=eol:$,tab:>\ ,extends:>,precedes:<,nbsp:+,trail:_
" Character used to mark wrapped lines
set showbreak==>\
" Copy the indentation from the previous line
set autoindent
" Short blink when typing matching parens
set showmatch
set matchtime=1
" Allow leaving modified buffers without saving
set hidden
" Try to keep windows similarly sized
set equalalways
set eadirection=both
" Don't show the active mode
set noshowmode
" Search as you're typing
set incsearch
" Allow backspacing over everything
set backspace=indent,eol,start
" Enable the mouse
set mouse=a
" Set US English for spellcheck
set spelllang=en_us
" Always show statusbar
set laststatus=2
" Don't wrap lines by default
set nowrap
" Don't page output
set more
" Default to new windows appearing below current
set splitbelow
" Don't try to set the cursor
set guicursor=
" Preview window is 1 line tall
set previewheight=1
" CursorHold kicks in after one second
set updatetime=1000
" Show cmd in progress
set showcmd
" Recursive searching
set path+=**
" Tab completion menu
set wildmenu
" TODO: Set this in an autocmd so that popups are unaffected
"try
"" Minimum active window size
"    set winwidth=80
"    set winheight=24
"    " Keep the cursor near the center of the screen
"    set scrolloff=8
"catch
"    set winheight=8
"    set scrolloff=1
"endtry
" Allow windows to collapse completely
set winminwidth=1
set winminheight=1
set completeopt+=menuone
set completeopt+=noinsert

filetype plugin indent on
" TODO: Auto-center the view when cursor would move off screen, like emacs
" }}}

" Functions {{{

function! s:is_loaded(name)
    if empty(filter(split(execute('scriptnames'), "\n"),
        \ 'v:val =~? "'.a:name.'"'))
        return 0
    endif
    return 1
endfunc

" Wrapper for setting highlights
function! s:hi(group, fg, bg, attr)
    let l:cmd = [ 'hi', a:group, 'guifg='.a:fg[0], 'guibg='.a:bg[0],
        \ 'gui='.a:attr, 'ctermfg='.a:fg[1], 'ctermbg='.a:bg[1],
        \ 'cterm='.a:attr ]
    execute join(l:cmd, ' ')
endfunc

func! SetStatusLime()
    let g:statuslime_left = 'left'
    let g:statuslime_right = 'right'
endfunc

" }}}

" Color Palette {{{

" srcery color palette
let s:black          = ['#1C1B19', 0]
let s:red            = ['#EF2F27', 1]
let s:green          = ['#519F50', 2]
let s:yellow         = ['#FBB829', 3]
let s:blue           = ['#2C78BF', 4]
let s:magenta        = ['#E02C6D', 5]
let s:cyan           = ['#0AAEB3', 6]
let s:white          = ['#D0BFA1', 7]
let s:bright_black   = ['#918175', 8]
let s:bright_red     = ['#F75341', 9]
let s:bright_green   = ['#98BC37', 10]
let s:bright_yellow  = ['#FED06E', 11]
let s:bright_blue    = ['#68A8E4', 12]
let s:bright_magenta = ['#FF5C8F', 13]
let s:bright_cyan    = ['#53FDE9', 14]
let s:bright_white   = ['#FCE8C3', 15]

" xterm colors.
let s:orange        = ['#FF5F00', 202]
let s:bright_orange = ['#FF8700', 208]
let s:hard_black    = ['#121212', 233]
let s:xgray1        = ['#262626', 235]
let s:xgray2        = ['#303030', 236]
let s:xgray3        = ['#3A3A3A', 237]
let s:xgray4        = ['#444444', 238]
let s:xgray5        = ['#4E4E4E', 239]
let s:xgray6        = ['#585858', 240]

let s:none = ['NONE', 'NONE']

" }}}

" Highlights {{{

call s:hi('Normal', s:bright_white, s:black, 'NONE')

for group in ['Visual', 'VisualNOS', 'Search', 'IncSearch']
    call s:hi(group, s:none, s:none, 'inverse')
endfor

for group in ['NonText', 'SpecialKey']
    call s:hi(group, s:xgray4, s:none, 'NONE')
endfor

call s:hi('MatchParen', s:bright_magenta, s:none, 'bold')
call s:hi('Conceal', s:xgray2, s:none, 'NONE')
call s:hi('StatusLine', s:bright_white, s:xgray1, 'NONE')
call s:hi('VertSplit', s:bright_white, s:none, 'NONE')
call s:hi('WildMenu', s:blue, s:black, 'bold')
call s:hi('ErrorMsg', s:bright_white, s:red, 'NONE')
call s:hi('Directory', s:green, s:none, 'bold')
call s:hi('Title', s:green, s:none, 'bold')
call s:hi('MoreMsg', s:yellow, s:none, 'bold')
call s:hi('Question', s:orange, s:none, 'bold')
call s:hi('Warning', s:red, s:none, 'bold')

call s:hi('Cursor', s:black, s:yellow, 'NONE')
hi! link vCursor Cursor
hi! link iCursor Cursor
hi! link lCursor Cursor

call s:hi('Special', s:orange, s:none, 'NONE')
call s:hi('Comment', s:bright_black, s:none, 'italic')
call s:hi('Todo', s:bright_white, s:black, 'bold,italic')
call s:hi('Error', s:bright_white, s:red, 'bold')
call s:hi('String', s:bright_green, s:none, 'NONE')

for group in ['Statement', 'Conditional', 'Repeat', 'Label', 'Exception', 'Keyword']
    call s:hi(group, s:red, s:none, 'NONE')
endfor

for group in ['Identifier', 'PreProc', 'Include', 'Define', 'PreCondit', 'Structure']
    call s:hi(group, s:cyan, s:none, 'NONE')
endfor

call s:hi('Function', s:yellow, s:none, 'NONE')
call s:hi('Macro', s:orange, s:none, 'NONE')

for group in ['Constant', 'Character', 'Boolean', 'Number', 'Float']
    call s:hi(group, s:bright_magenta, s:none, 'NONE')
endfor

call s:hi('Type', s:bright_blue, s:none, 'NONE')
call s:hi('StorageClass', s:orange, s:none, 'NONE')
call s:hi('Typedef', s:magenta, s:none, 'NONE')
call s:hi('Delimiter', s:bright_black, s:none, 'NONE')

" Make folds blend in so that the status bar and splits are easier to identify
call s:hi('Folded', s:none, s:none, 'italic')
call s:hi('LineNr', s:white, s:xgray1, 'NONE')
call s:hi('CursorLineNr', s:xgray1, s:bright_black, 'NONE')
call s:hi('StatusLineNC', s:xgray3, s:xgray1, 'NONE')

call s:hi('Pmenu', s:bright_white, s:xgray2, 'NONE')
call s:hi('PmenuSel', s:bright_white, s:magenta, 'bold')

call s:hi('DiffDelete', s:red, s:black, 'none')
call s:hi('DiffAdd', s:green, s:black, 'none')
call s:hi('DiffChange', s:cyan, s:black, 'none')
call s:hi('DiffText', s:yellow, s:black, 'none')

if has('spell')
    call s:hi('SpellCap', s:none, s:magenta, 'underline')
    call s:hi('SpellBad', s:none, s:red, 'underline')
    call s:hi('SpellLocal', s:none, s:yellow, 'underline')
    call s:hi('SpellRare', s:none, s:cyan, 'underline')
endif
if has('terminal')
    call s:hi('Terminal', s:bright_white, s:hard_black, 'NONE')
endif

" statuslime colors
call s:hi('LimeNormal',       s:hard_black,    s:white,   'bold')
call s:hi('LimeVisual',       s:hard_black,    s:blue,    'bold')
call s:hi('LimeInsert',       s:hard_black,    s:yellow,  'bold')
call s:hi('LimeReplace',      s:hard_black,    s:orange,  'bold')
call s:hi('LimeTerminal',     s:hard_black,    s:green,   'bold')
call s:hi('LimeCommand',      s:hard_black,    s:magenta, 'bold')
call s:hi('LimeShell',        s:hard_black,    s:cyan,    'bold')
call s:hi('LimeOther',        s:hard_black,    s:red,     'bold')
call s:hi('LimeFile',         s:bright_white,  s:xgray3,  'NONE')
call s:hi('LimeError',        s:bright_red,    s:xgray1,  'bold')
call s:hi('LimeRuler',        s:bright_white,  s:xgray2,  'NONE')
call s:hi('LimeInactiveBar',  s:hard_black,    s:xgray2,  'NONE')
call s:hi('LimeInactiveMode', s:hard_black,    s:xgray3,  'NONE')
call s:hi('LimeLeft',         s:bright_orange, s:xgray1,  'NONE')
call s:hi('LimeRight',        s:bright_yellow, s:xgray1,  'NONE')

" buftabline colors
call s:hi('BufTabLineCurrent', s:hard_black, s:white, 'bold')
call s:hi('BufTabLineActive', s:blue, s:white, 'NONE')
call s:hi('BufTabLineHidden', s:bright_black, s:white, 'NONE')
call s:hi('BufTabLineFill', s:black, s:bright_black, 'NONE')

" }}}

" Maps {{{

if has("terminal")
    " Navigate out of terminal mode more easily
    tnoremap <esc> <c-\><c-n>
    tnoremap <c-w> <c-\><c-n><c-w>
endif
" Reset layout
nnoremap <leader>r <C-W>=
" Quick reload of vimrc
nnoremap <leader>R :source $MYVIMRC<cr>
" Toggle spellcheck
nnoremap <leader>S :set spell!<cr>
" Clear search with <C-L>
nnoremap <c-l> :noh<cr><c-l>

nnoremap ` <c-w>
nnoremap <c-w>` `

nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)

noremap <silent><leader>? :call quickmenu#toggle(g:plugin_help_menu)<cr>
noremap <silent><leader>g :GitMessenger<cr>

nmap ga <Plug>(EasyAlign)
vmap <Enter> <Plug>(EasyAlign)

" }}}

" Plugin Configuration {{{

let g:mucomplete#enable_auto_at_startup = 1

let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_list_hide = netrw_gitignore#Hide()

let g:indentLine_char_list = ['|', '¦', '┆', '┊']
let g:indentLine_setColors = 0

let g:buftabline_indicators = 1
let g:buftabline_numbers = 2

let g:git_messenger_include_diff = v:true
let g:git_messenger_max_popup_height = 8

let g:echodoc#enable_at_startup = 1

let g:quickmenu_options = "H"
try
    " Populate quickmenu with installed plugins with helpfiles
    call quickmenu#current(g:plugin_help_menu)
    call quickmenu#reset()
    call quickmenu#header('plugin help')
    for p in g:plugin_help_list
        let short = substitute(
                \ substitute(
                    \ split(p, '/')[1],
                \ 'vim-', '', 'g'),
            \ '.vim', '', 'g')
        call quickmenu#append(short, 'h '.short.'.txt', '')
    endfor
catch
    echom 'quickmenu could not be initialized'
endtry
" }}}


" TODO: Move this to a plugin
" This shades the background of every 5th line to give
" a similar benefit to relative line numbers without
" the visual clutter
" TODO: blank lines are skipped, find a solution
let cidx = 1
for c in [s:xgray1, s:xgray2, s:xgray3, s:xgray4, s:xgray5, s:xgray6]
    call s:hi('LineMark'.cidx, s:none, c, 'NONE')
    let cidx += 1
endfor

func! ClearLineHelpers()
    call clearmatches()
endfunc

func! SetLineHelpers()
    call clearmatches()
    if &ro
        return
    endif
    let l:win = winsaveview()
    let l:interval = 5
    let l:line = line('.') - l:interval
    let l:cidx = 1
    while l:line > l:win['topline']
        call matchaddpos('LineMark'.l:cidx, [l:line])
        let l:line -= l:interval
        if l:cidx < 6
            let l:cidx += 1
        endif
    endwhile
    let l:line = line('.') + l:interval
    let l:height = winheight(0)
    let l:cidx = 1
    while l:line < l:win['topline']+l:height
        call matchaddpos('LineMark'.l:cidx, [l:line])
        let l:line += l:interval
        if l:cidx < 6
            let l:cidx += 1
        endif
    endwhile
endfunc

au! CursorHold * call SetLineHelpers()
au! CursorMoved * call ClearLineHelpers()

if has('nvim') == 0
    finish
endif

try
    lua << ENDLUA
require'nvim_lsp'.pyls.setup{}
require'nvim_lsp'.clangd.setup{}
require'nvim_lsp'.bashls.setup{}
require'nvim_lsp'.dockerls.setup{}
ENDLUA
catch
    echom 'nvim-lsp could not start'
    finish
endtry

set omnifunc=v:lua.vim.lsp.omnifunc
nnoremap <silent> gd    <cmd>lua vim.lsp.buf.declaration()<CR>
nnoremap <silent> <c-]> <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap <silent> K     <cmd>lua vim.lsp.buf.hover()<CR>
nnoremap <silent> gD    <cmd>lua vim.lsp.buf.implementation()<CR>
nnoremap <silent> <c-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
nnoremap <silent> 1gD   <cmd>lua vim.lsp.buf.type_definition()<CR>
nnoremap <silent> gr    <cmd>lua vim.lsp.buf.references()<CR>


