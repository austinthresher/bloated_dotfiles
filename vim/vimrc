set encoding=utf-8 | scriptencoding utf-8
function! g:Options()
    " Allow folding in files
    set foldenable
    " No annoying sounds / flashes
    set noerrorbells
    " Allow files to customize settings on open
    set modeline
    " Characters used when list=on
    set listchars=eol:$,tab:>\ ,extends:>,precedes:<,nbsp:+,trail:_
    " Character used to mark wrapped lines
    set showbreak==>\
    " Copy the indentation from the previous line
    set autoindent
    " Short blink when typing matching parens
    set showmatch
    set matchtime=1
    " Allow leaving modified buffers without saving
    set hidden
    " Try to keep windows similarly sized
    set equalalways
    set eadirection=both
    " Don't show the active mode
    set noshowmode
    " Search as you're typing
    set incsearch
    set hlsearch
    " Allow backspacing over everything
    set backspace=indent,eol,start
    " Enable the mouse
    set mouse=a
    " Set US English for spellcheck
    set spelllang=en_us
    " Always show statusbar
    set laststatus=2
    " Don't wrap lines by default
    set nowrap
    " Don't page output
    set more
    " Default to new windows appearing below current
    set splitbelow
    " Don't try to set the cursor
    set guicursor=
    " Preview window is small
    "set previewheight=3
    " CursorHold kicks in after 1/10 second
    set updatetime=100
    " Reduce screen artifacts by delaying redraw
    set lazyredraw
    " Show cmd in progress
    set showcmd
    " Recursive searching
    set path+=**
    " Tab completion menu
    set wildmenu
    " Scroll options
    set sidescroll=1
    set scrolloff=0
    set sidescrolloff=1
    " Allow windows to collapse completely
    set winminwidth=1
    set winminheight=1
    set completeopt+=menuone,noinsert,preview,longest
    " Default tab settings
    set shiftwidth=4
    set softtabstop=4
    set expandtab
    " Use line drawing char for vsp, spaces for folds
    if has('nvim')
        set fillchars=vert:â”‚,fold:\ ,eob:\ ,diff:-
    else " vim doesn't have the eob option
        set fillchars=vert:â”‚,fold:\ ,diff:-
    endif
    " Use filetype-based plugin and indent scripts
    filetype plugin indent on
    " Use ag instead of grep if present
    if executable('ag')
        set grepprg=ag\ --nogroup\ --nocolor\ --column
        set grepformat=%f:%l:%c%m
    endif

    " Simplify quickfix by ignoring any line that isn't an error or warning
    set errorformat=%f:%l:%c:\ %trror:\ %m
    set errorformat+=%f:%l:%c:\ %tarning:\ %m
    set errorformat+=%f:(%.%#):\ %m
    set errorformat+=%-G%.%#
    " TODO: display link errors

endfunc
call g:Options()

function! g:Globals()
    try
        let g:lyra_string_bg = v:false
        let g:lyra_use_system_colors = v:true
        let g:lyra_transparent = v:true
        colorscheme lyra
    endtry
    let g:cmake_build_dir = 'build'
    let g:ide = has('nvim')
    let g:nproc = 1
    try | let g:nproc = str2nr(system('nproc')) | endtry
    let g:python_highlight_all = v:true
endfunction
call g:Globals()

function! g:Plugins()
    if has('nvim')
        let g:helper_plug_path = $HOME.'/.config/nvim/repos'
    else
        let g:helper_plug_path = $HOME.'/.vim/repos'
    endif

    call helper#begin()

    call helper#plug('MarcWeber/vim-addon-mw-utils')
    call helper#plug('ekalinin/dockerfile.vim')
    call helper#plug('google/vim-searchindex')
    call helper#plug('guns/xterm-color-table.vim')
    call helper#plug('junegunn/gv.vim')
    call helper#plug('jvirtanen/vim-octave')
    call helper#plug('machakann/vim-sandwich')
    call helper#plug('mboughaba/i3config.vim')
    call helper#plug('michaeljsmith/vim-indent-object')
    call helper#plug('peterrincker/vim-argumentative')
    call helper#plug('romainl/vim-qf')
    call helper#plug('roxma/vim-paste-easy')
    call helper#plug('tbastos/vim-lua')
    call helper#plug('terryma/vim-multiple-cursors')
    call helper#plug('thinca/vim-ref')
    call helper#plug('tomtom/tlib_vim')
    call helper#plug('tpope/vim-abolish')
    call helper#plug('tpope/vim-apathy')
    call helper#plug('tpope/vim-commentary')
    call helper#plug('tpope/vim-eunuch')
    call helper#plug('tpope/vim-fugitive')
    call helper#plug('tpope/vim-markdown')
    call helper#plug('tpope/vim-sensible')
    call helper#plug('tpope/vim-unimpaired')
    call helper#plug('tpope/vim-vinegar')
    call helper#plug('tpope/vim-git')
    call helper#plug('tpope/vim-obsession')
    call helper#plug('chrisbra/csv.vim')
    call helper#plug('pboettch/vim-cmake-syntax')
    call helper#plug('vim-scripts/std_c.zip')
    call helper#plug('triglav/vim-visual-increment')
    call helper#plug('vim-scripts/armasm')
    call helper#plug('jonhiggs/vim-readline')
    call helper#plug('bfrg/vim-cpp-modern')

    if helper#plug('pseewald/vim-anyfold')
        augroup Anyfold
            autocmd!
            autocmd Filetype * AnyFoldActivate
            autocmd Filetype * exec 'norm! zR'
            autocmd Filetype * set foldlevel=99
        augroup END
        let g:anyfold_fold_comments = v:true
    endif


    if helper#plug('noahfrederick/vim-skeleton')
        if has('nvim')
            let g:skeleton_template_dir = $HOME.'/.config/nvim/templates'
        else
            let g:skeleton_template_dir = $HOME.'/.vim/templates'
        endif

    endif

    if helper#plug('ctrlpvim/ctrlp.vim')
        let g:ctrlp_map = '<leader>f'
        let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
        let g:ctrlp_extensions = []
    endif

    if helper#plug('suy/vim-ctrlp-commandline')
        let g:ctrlp_extensions += ['commandline']
    endif

    if helper#plug('szw/vim-g')
        nmap <leader>G :Googlef<cr>
        vmap <leader>G :Googlef<cr>
    endif

    if helper#plug('ap/vim-buftabline')
        let g:buftabline_indicators = 1
        let g:buftabline_numbers = 0
        nmap <leader>1 <Plug>BufTabLine.Go(1)
        nmap <leader>2 <Plug>BufTabLine.Go(2)
        nmap <leader>3 <Plug>BufTabLine.Go(3)
        nmap <leader>4 <Plug>BufTabLine.Go(4)
        nmap <leader>5 <Plug>BufTabLine.Go(5)
        nmap <leader>6 <Plug>BufTabLine.Go(6)
        nmap <leader>7 <Plug>BufTabLine.Go(7)
        nmap <leader>8 <Plug>BufTabLine.Go(8)
        nmap <leader>9 <Plug>BufTabLine.Go(9)
        nmap <leader>0 <Plug>BufTabLine.Go(10)
    endif " buftabline

    if helper#plug('junegunn/vim-easy-align')
        nmap ga <Plug>(EasyAlign)
        vmap <Enter> <Plug>(EasyAlign)
    endif " easy-align

    if helper#plug('rhysd/conflict-marker.vim')
        let g:conflict_marker_enable_mappings = 0
        nmap <buffer>]x <Plug>(conflict-marker-next-hunk)
        nmap <buffer>[x <Plug>(conflict-marker-prev-hunk)
    endif " conflict-marker

    if helper#plug('rhysd/git-messenger.vim')
        let g:git_messenger_no_default_mappings = v:true
        let g:git_messenger_include_diff = v:true
        let g:git_messenger_max_popup_height = 8
        noremap <silent><leader>g :GitMessenger<cr>
    endif " git-messenger

    if helper#plug('wellle/visual-split.vim')
        xmap <leader>p <Plug>(Visual-Split-SplitAbove)
        xmap <leader>n <Plug>(Visual-Split-Resize)
        nmap <leader>p <Plug>(Visual-Split-SplitAbove)
        nmap <leader>n <Plug>(Visual-Split-Resize)
    endif " visual-split

    if helper#plug('mattboehm/vim-accordion')
        augroup Accordion
            autocmd!
            autocmd VimEnter * silent! AccordionAll 2
        augroup END
        nnoremap <leader><pageup> :AccordionZoomOut<CR>
        nnoremap <leader><pagedown> :AccordionZoomIn<CR>
        nnoremap <c-w>2 :Accordion 2<CR>
        nnoremap <c-w>3 :Accordion 3<CR>
        nnoremap <c-w>4 :Accordion 4<CR>
    endif " accordion

    if helper#plug('thaerkh/vim-indentguides')
        if $WSL_DISTRO_NAME ==# ''
            let g:indentguides_spacechar = 'ðŸ®Œ'
            let g:indentguides_tabchar = 'â–‘'
        else
            let g:indentguides_spacechar = '|'
            let g:indentguides_tabchar = '>'
        endif
        let g:indentguides_toggleListMode = v:false
        let g:indentguides_firstlevel = v:false
    endif " indentguides

    " TODO: try neoformat
    if helper#plug('chiel92/vim-autoformat')
        let g:formatterpath = [$HOME.'/.local/bin']
        let g:autoformat_autoindent = 0
        let g:autoformat_retab = 0
        let g:formatters_python = ['yapf']
        let g:formatdef_yapf = '"yapf --style=\"$HOME/.style.yapf\""'
        noremap <leader>F :Autoformat<CR>
    endif " autoformat

    if helper#plug('moll/vim-bbye')
        nnoremap <leader>Q :Bdelete<CR>
    endif " bbye

    if g:ide
        if helper#plug('neoclide/coc.nvim')
            set hidden
            set nobackup nowritebackup
            set updatetime=250
            set shortmess+=c
            "set signcolumn=yes
            inoremap <silent><expr> <Tab>
                        \ pumvisible() ? "\<C-n>" :
                        \ <SID>check_back_space() ? "\<Tab>" :
                        \ coc#refresh()
            inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<C-h>"

            function s:check_back_space() abort
                let col = col('.') - 1
                return !col || getline('.')[col - 1] =~# '\s'
            endfunction

            inoremap <silent><expr> <c-space> coc#refresh()
            if has('patch8.1.1068')
                inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<cr>"
            else
                imap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<cr>"
            endif

            nmap <silent> gd <Plug>(coc-definition)
            nmap <silent> gy <Plug>(coc-type-definition)
            nmap <silent> gi <Plug>(coc-implementation)
            nmap <silent> gr <Plug>(coc-references)
        endif
        call helper#plug('honza/vim-snippets')
        if helper#plug('neomake/neomake')
            func! SetStatusLime()
                let b:statuslime_right = neomake#statusline#get(bufnr('%'), {
                            \ 'use_highlights_with_defaults': 0,
                            \ 'format_running': '{{running_job_names}}',
                            \ 'format_loclist_ok': 'âœ“',
                            \ 'format_loclist_issues': '%s',
                            \ 'format_quickfix_ok': '',
                            \ 'format_quickfix_issues': '%s',
                            \ 'format_loclist_type_W': '{{count}} warning(s) ',
                            \ 'format_loclist_type_E': '{{count}} error(s) ',
                            \ 'format_loclist_type_I': '{{count}} message(s) ',
                            \ })
                let b:statuslime_left = coc#status()
            endfunc
            " Don't report issues inside system headers
            function PostprocessClangTidy(entry)
                try
                    let l:fname = a:entry['filename']
                catch
                    let l:fname = bufname(a:entry['bufnr'])
                endtry
                try
                    if l:fname =~# '/usr/include'
                        let a:entry['valid'] = -1
                    endif
                endtry
            endfunction
            let g:neomake_open_list = 2
            let g:neomake_highlight_columns = 0
            let g:neomake_makers_buffer_output = 0
            let g:neomake_virtualtext_current_error = 0
            let g:neomake_info_sign          = { 'text': 'â–·' }
            let g:neomake_message_sign       = { 'text': 'â–¶' }
            let g:neomake_cpp_enabled_makers = executable('clang++') ?
                        \ ['clangtidy'] : ['gcc']
            let g:neomake_cpp_clangtidy_maker = {
                        \ 'exe': '/home/athresher/.local/share/clang/run-clang-tidy.py',
                        \ 'args': [
                        \       '-quiet',
                        \       '-j', string(g:nproc),
                        \       '-checks=-*,bugprone-*,cppcoreguidelines-*,'
                        \           .'clang-analyzer*,hicpp-*,misc-*,modernize-*,mpi-*,'
                        \           .'openmp-*,performance-*,readability-*,portability-*'
                        \ ],
                        \ 'postprocess': function('PostprocessClangTidy'),
                        \ 'errorformat':
                        \       '%E%f:%l:%c: fatal error: %m,' .
                        \       '%E%f:%l:%c: error: %m,' .
                        \       '%W%f:%l:%c: warning: %m,' .
                        \       '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
                        \       '%E%m'
                        \}
            call add(g:neomake_cpp_enabled_makers, 'cppcheck')

        endif " neomake
    endif

    call helper#end()
endfunction
call g:Plugins()

function! g:Functions()
    " Useful for debugging syntax highlighting
    func! HiAtCur()
        let l:name = ''
        for id in synstack(line('.'), col('.'))
            let l:name = synIDattr(id, 'name')
            echo l:name
        endfor
        if l:name isnot# ''
            exec 'hi '.l:name
        endif
    endfunc

    function! CMakeBuildDir()
        return exists('b:cmake_build_dir') ? 
                    \ b:cmake_build_dir :
                    \ (exists('g:cmake_build_dir') ?
                        \ g:cmake_build_dir : 'build')
    endfunction

    function! RunCMakeAndMake(args)
        if filereadable('CMakeLists.txt')
            let l:build = CMakeBuildDir()
            let l:cmd = '!cmake -B '.CMakeBuildDir().' -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -S $(pwd) '.a:args
            silent exec l:cmd
            silent exec 'make -C '.CMakeBuildDir()
            redraw!
            echom l:cmd
        else
            silent exec 'make'
            redraw!
            echom 'make'
        endif
    endfunction

    function! RunMakeClean()
        if filereadable('CMakeLists.txt')
            let l:cmd = 'make -C '.CMakeBuildDir().' clean'
        else
            let l:cmd = 'make clean'
        endif
        silent exec l:cmd
        redraw!
        echom l:cmd
    endfunction

    " Show and jump to quickfix, close quickfix when in the list
    function! ToggleQuickfix()
        if &buftype ==# 'quickfix'
            wincmd p
            exec 'cclose'
        else
            exec 'copen 5'
        endif
    endfunction

    " Snaps view to left when line < window width
    function! ViewSnap()
        let l:view = winsaveview()
        let l:left = l:view['leftcol']
        let l:col = l:view['col']
        let l:linelen = strwidth(getline('.'))
        let l:winlen = winwidth(0)
        if l:left > 0 && l:linelen < l:winlen
            let l:view['leftcol'] = 0
            call winrestview(l:view)
        endif
    endfunction
endfunction
call g:Functions()

function! g:Maps()
    " Navigate out of terminal mode more easily
    tnoremap <esc> <c-\><c-n>
    tnoremap <c-w>H <c-\><c-n><c-w>H
    tnoremap <c-w>J <c-\><c-n><c-w>J
    tnoremap <c-w>K <c-\><c-n><c-w>K
    tnoremap <c-w>L <c-\><c-n><c-w>L
    tnoremap <c-w>h <c-\><c-n><c-w>h
    tnoremap <c-w>j <c-\><c-n><c-w>j
    tnoremap <c-w>k <c-\><c-n><c-w>k
    tnoremap <c-w>l <c-\><c-n><c-w>l
    tnoremap <c-w>p <c-\><c-n><c-w>p

    " Snap view to left if line length is <= win width
    augroup ViewSnapAU
        autocmd!
        autocmd CursorMoved,CursorMovedI * call ViewSnap()
    augroup END

    nnoremap <silent> Q :call ToggleQuickfix()<cr>
    nmap <leader>q :q<cr>
    nmap <leader>l :copen<cr>
    nmap <silent> <leader>C :call RunMakeClean()<cr>
    nmap <silent> <leader>M :call RunCMakeAndMake('-DCMAKE_CXX_CLANG_TIDY=clang-tidy')<cr>
    nmap <silent> <leader>m :call RunCMakeAndMake('-UCMAKE_CXX_CLANG_TIDY=')<cr>

    " Automatically enter insert mode when selecting terminal window
    augroup Terminal
        autocmd!
        if has('nvim')
            autocmd TermOpen * startinsert
        else
            autocmd BufEnter * silent! if &buftype ==# 'terminal' | exec 'norm i' | endif
        endif
    augroup END

    " Quick reload of vimrc
    nnoremap <leader>V :source $MYVIMRC<cr>
    " Clear search with <C-L>
    nnoremap <c-l> :noh<cr><c-l>
    " Use ` as optional wincmd prefix
    nnoremap ` <c-w>
    nnoremap <c-w>` `
    nmap <silent><leader>? <Plug>(helper-toggle)
    " Ctrl+K to search for cursor text and show in quickfix
    nnoremap <c-k> :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

    nnoremap <leader>h :call HiAtCur()<cr>

    " Makes * select the cursor word but not jump to next match
    nnoremap * *N

endfunction
call g:Maps()

function! g:IDE()
        call neomake#configure#automake({
                    \ 'TextChanged': {},
                    \ 'InsertLeave': {},
                    \ 'BufWritePost': {'delay': 0},
                    \ 'BufWinEnter': {},
                    \}, 100)
        call neomake#signs#RedefineErrorSign({ 'text': 'â•³', 'texthl': 'Error' })
        call neomake#signs#RedefineWarningSign({ 'text': 'âœ—', 'texthl': 'Error' })
endfunction
if g:ide | call g:IDE() | endif
