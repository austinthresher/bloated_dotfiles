
set shiftwidth=4
set softtabstop=4
set expandtab

" Plugins {{{

" Keep track of plugins to auto-generate help menu
let g:plugin_master_list = []
let g:plugin_help_list = []
func! s:plug(repo, has_help)
    try
        call plug#(a:repo)
        let g:plugin_master_list = g:plugin_master_list + [a:repo]
        if a:has_help != 0
            let g:plugin_help_list = g:plugin_help_list + [a:repo]
        endif
    catch
        echoerr 'Failed to load plugin "'.a:repo.'"'
    endtry
endfunc
let g:plugin_help_menu = 1

if has('nvim')
    let g:plugin_path = '~/.config/nvim/repos'
else
    let g:plugin_path = '~/.vim/repos'
endif

try
    call plug#begin(g:plugin_path)

    " TODO: Compare cpp highlighters
    "call s:plug('bfrg/vim-cpp-modern', v:false)
    "call s:plug('octol/vim-cpp-enhanced-highlight', v:false)
    
    call s:plug('ap/vim-buftabline', v:true)
    call s:plug('ekalinin/dockerfile.vim', v:false)
    call s:plug('google/vim-searchindex', v:true)
    call s:plug('guns/xterm-color-table.vim', v:true)
    call s:plug('junegunn/gv.vim', v:false) " git commit browser
    call s:plug('junegunn/vim-easy-align', v:true)
    call s:plug('machakann/vim-sandwich', v:true)
    call s:plug('mboughaba/i3config.vim', v:false)
    call s:plug('michaeljsmith/vim-indent-object', v:true)
    call s:plug('peterrincker/vim-argumentative', v:true)
    call s:plug('reedes/vim-litecorrect', v:false)
    call s:plug('rhysd/conflict-marker.vim', v:true) " [x ]x
    call s:plug('rhysd/git-messenger.vim', v:true)
    call s:plug('roxma/vim-paste-easy', v:false)
    call s:plug('sheerun/vim-polyglot', v:false)
    call s:plug('skywind3000/quickmenu.vim', v:false)
    call s:plug('tbastos/vim-lua', v:false)
    call s:plug('thinca/vim-ref', v:true)
    call s:plug('tpope/vim-abolish', v:true)
    call s:plug('tpope/vim-commentary', v:true)
    call s:plug('tpope/vim-eunuch', v:true)
    call s:plug('tpope/vim-fugitive', v:true)
    call s:plug('tpope/vim-rsi', v:true)
    call s:plug('tpope/vim-sensible', v:false)
    call s:plug('tpope/vim-unimpaired', v:true)
    call s:plug('tpope/vim-vinegar', v:true)
    call s:plug('yggdroot/indentline', v:true)

    if has('nvim')
        call s:plug('prabirshrestha/async.vim', v:false)
        call s:plug('prabirshrestha/vim-lsp', v:true)
        call s:plug('prabirshrestha/asyncomplete.vim', v:false)
        call s:plug('prabirshrestha/asyncomplete-lsp.vim', v:false)
    endif

    call plug#end()
catch
    echom "vim-plug is missing or broken"
endtry

" }}}

" Options {{{
" Disable vi-compatible defaults
set nocompatible
" Allow folding in files using {{{ and }}}
set foldenable
set foldmethod=marker
" Always use UTF-8
set encoding=utf-8
scriptencoding utf-8
" No annoying sounds / flashes
set noerrorbells
" Allow files to customize settings on open
set modeline
" Characters used when list=on
set listchars=eol:$,tab:>\ ,extends:>,precedes:<,nbsp:+,trail:_
" Character used to mark wrapped lines
set showbreak==>\
" Copy the indentation from the previous line
set autoindent
" Short blink when typing matching parens
set showmatch
set matchtime=1
" Allow leaving modified buffers without saving
set hidden
" Try to keep windows similarly sized
set equalalways
set eadirection=both
" Don't show the active mode
set noshowmode
" Search as you're typing
set incsearch
" Allow backspacing over everything
set backspace=indent,eol,start
" Enable the mouse
set mouse=a
" Set US English for spellcheck
set spelllang=en_us
" Always show statusbar
set laststatus=2
" Don't wrap lines by default
set nowrap
" Don't page output
set more
" Default to new windows appearing below current
set splitbelow
" Don't try to set the cursor
set guicursor=
" Preview window is 1 line tall
"set previewheight=1
" CursorHold kicks in after 1/10 second
set updatetime=100
" Show cmd in progress
set showcmd
" Recursive searching
set path+=**
" Tab completion menu
set wildmenu
" Don't scroll near borders, use an autocmd to do that
set scrolloff=0
" Allow windows to collapse completely
set winminwidth=1
set winminheight=1
set completeopt+=menuone
set completeopt+=noinsert

set fillchars=vert:│,fold:\ ,diff:-

filetype plugin indent on

" }}}

" Functions {{{

function! s:is_loaded(name)
    if empty(filter(split(execute('scriptnames'), "\n"),
        \ 'v:val =~? "'.a:name.'"'))
        return 0
    endif
    return 1
endfunc

" Wrapper for setting highlights
function! s:hi(group, fg, bg, attr)
    let l:cmd = [ 'hi', a:group, 'guifg='.a:fg[0], 'guibg='.a:bg[0],
        \ 'gui='.a:attr, 'ctermfg='.a:fg[1], 'ctermbg='.a:bg[1],
        \ 'cterm='.a:attr ]
    execute join(l:cmd, ' ')
endfunc

func! SetStatusLime()
    let b:statuslime_left = ''
    let b:statuslime_right = has('nvim') ? 'N' : 'V'
    return ''
endfunc

" }}}

" Color Palette {{{

" 16 ANSI colors
let s:xterm_black          = has('nvim') ? 234 : 233
let s:xterm_red            = has('nvim') ? 197 : 52
let s:xterm_green          = has('nvim') ? 112 : 22
let s:xterm_yellow         = has('nvim') ? 221 : 208
let s:xterm_blue           = has('nvim') ? 75  : 32
let s:xterm_magenta        = has('nvim') ? 127 : 199
let s:xterm_cyan           = has('nvim') ? 84  : 49
let s:xterm_white          = has('nvim') ? 252 : 252
let s:xterm_bright_black   = has('nvim') ? 241 : 59
let s:xterm_bright_red     = has('nvim') ? 203 : 196
let s:xterm_bright_green   = has('nvim') ? 118 : 41
let s:xterm_bright_yellow  = has('nvim') ? 227 : 220
let s:xterm_bright_blue    = has('nvim') ? 147 : 45
let s:xterm_bright_magenta = has('nvim') ? 165 : 170
let s:xterm_bright_cyan    = has('nvim') ? 122 : 159
let s:xterm_bright_white   = has('nvim') ? 255 : 231
" Darker than black
let s:xterm_dark_black     = has('nvim') ? 233 : 232
" Darker than bright_black, lighter than black
let s:xterm_darkest_gray   = has('nvim') ? 235 : 234
let s:xterm_darker_gray    = has('nvim') ? 237 : 235
let s:xterm_dark_gray      = has('nvim') ? 239 : 237
" Lighter than bright_black, darker than white
let s:xterm_light_gray     = has('nvim') ? 243 : 244
let s:xterm_lighter_gray   = has('nvim') ? 245 : 247
let s:xterm_lightest_gray  = has('nvim') ? 247 : 250

if has('nvim') " neovim theme
    let s:black          = ['#1C1B19', s:xterm_black]
    let s:red            = ['#EF2F27', s:xterm_red]
    let s:green          = ['#519F50', s:xterm_green]
    let s:yellow         = ['#FBB829', s:xterm_yellow]
    let s:blue           = ['#2C78BF', s:xterm_blue]
    let s:magenta        = ['#E02C6D', s:xterm_magenta]
    let s:cyan           = ['#0AAEB3', s:xterm_cyan]
    let s:white          = ['#D0BFA1', s:xterm_white]
    let s:bright_black   = ['#918175', s:xterm_bright_black]
    let s:bright_red     = ['#F75341', s:xterm_bright_red]
    let s:bright_green   = ['#98BC37', s:xterm_bright_green]
    let s:bright_yellow  = ['#FED06E', s:xterm_bright_yellow]
    let s:bright_blue    = ['#68A8E4', s:xterm_bright_blue]
    let s:bright_magenta = ['#FF5C8F', s:xterm_bright_magenta]
    let s:bright_cyan    = ['#53FDE9', s:xterm_bright_cyan]
    let s:bright_white   = ['#FCE8C3', s:xterm_bright_white]
    let s:dark_black     = ['#121212', s:xterm_dark_black]
    let s:darkest_gray   = ['#262626', s:xterm_darkest_gray]
    let s:darker_gray    = ['#303030', s:xterm_darker_gray]
    let s:dark_gray      = ['#3A3A3A', s:xterm_dark_gray]
    let s:light_gray     = ['#444444', s:xterm_light_gray]
    let s:lighter_gray   = ['#4E4E4E', s:xterm_lighter_gray]
    let s:lightest_gray  = ['#585858', s:xterm_lightest_gray]
else " vim theme
    let s:black          = ['#121212', s:xterm_black]
    let s:red            = ['#5F0000', s:xterm_red]
    let s:green          = ['#005F00', s:xterm_green]
    let s:yellow         = ['#FF8700', s:xterm_yellow]
    let s:blue           = ['#0087DF', s:xterm_blue]
    let s:magenta        = ['#FF00AF', s:xterm_magenta]
    let s:cyan           = ['#00FFAF', s:xterm_cyan]
    let s:white          = ['#D0D0D0', s:xterm_white]
    let s:bright_black   = ['#5F5F5F', s:xterm_bright_black]
    let s:bright_red     = ['#FF0000', s:xterm_bright_red]
    let s:bright_green   = ['#00DF5F', s:xterm_bright_green]
    let s:bright_yellow  = ['#FFDF00', s:xterm_bright_yellow]
    let s:bright_blue    = ['#00DFFF', s:xterm_bright_blue]
    let s:bright_magenta = ['#DF5FDF', s:xterm_bright_magenta]
    let s:bright_cyan    = ['#AFFFFF', s:xterm_bright_cyan]
    let s:bright_white   = ['#FFFFFF', s:xterm_bright_white]
    let s:dark_black     = ['#080808', s:xterm_dark_black]
    let s:darkest_gray   = ['#1C1C1C', s:xterm_darkest_gray]
    let s:darker_gray    = ['#262626', s:xterm_darker_gray]
    let s:dark_gray      = ['#3A3A3A', s:xterm_dark_gray]
    let s:light_gray     = ['#808080', s:xterm_light_gray]
    let s:lighter_gray   = ['#9E9E9E', s:xterm_lighter_gray]
    let s:lightest_gray  = ['#BCBCBC', s:xterm_lightest_gray]
endif

let s:none = ['NONE', 'NONE']

" }}}

" Highlights {{{

call s:hi('Normal', s:bright_white, s:black, 'NONE')

for group in ['Visual', 'VisualNOS', 'Search', 'IncSearch']
    call s:hi(group, s:none, s:none, 'inverse')
endfor

for group in ['NonText', 'SpecialKey']
    call s:hi(group, s:light_gray, s:none, 'NONE')
endfor

call s:hi('Operator', s:white, s:none, 'NONE')
call s:hi('MatchParen', s:bright_magenta, s:none, 'bold')
call s:hi('Conceal', s:darker_gray, s:none, 'NONE')
call s:hi('StatusLine', s:bright_white, s:darkest_gray, 'NONE')
call s:hi('VertSplit', s:bright_white, s:none, 'NONE')
call s:hi('WildMenu', s:blue, s:black, 'bold')
call s:hi('ErrorMsg', s:bright_white, s:red, 'NONE')
call s:hi('Directory', s:green, s:none, 'bold')
call s:hi('Title', s:green, s:none, 'bold')
call s:hi('MoreMsg', s:yellow, s:none, 'bold')
call s:hi('Question', s:bright_yellow, s:none, 'bold')
call s:hi('Warning', s:red, s:none, 'bold')

call s:hi('Cursor', s:black, s:yellow, 'NONE')
hi! link vCursor Cursor
hi! link iCursor Cursor
hi! link lCursor Cursor

call s:hi('Special', s:yellow, s:none, 'NONE')
call s:hi('Comment', s:bright_green, s:none, 'italic')
call s:hi('Todo', s:bright_yellow, s:black, 'bold,italic')
call s:hi('Error', s:bright_red, s:none, 'italic')
call s:hi('String', s:cyan, s:dark_black, 'NONE')
call s:hi('SpecialChar', s:bright_yellow, s:dark_black, 'italic')

for group in ['Constant', 'Character', 'Boolean', 'Number', 'Float']
    call s:hi(group, s:bright_red, s:none, 'NONE')
endfor

call s:hi('Type', s:bright_blue, s:none, 'NONE')
call s:hi('StorageClass', s:bright_blue, s:none, 'NONE')
call s:hi('Typedef', s:bright_blue, s:none, 'NONE')
call s:hi('Structure', s:bright_blue, s:none, 'NONE')
call s:hi('Delimiter', s:bright_black, s:none, 'NONE')
for group in ['Statement', 'Conditional', 'Repeat', 'Label', 'Exception', 'Keyword']
    call s:hi(group, s:blue, s:none, 'bold')
endfor
call s:hi('Identifier', s:bright_white, s:none, 'NONE')
call s:hi('PreProc',   s:yellow, s:none, 'NONE')
call s:hi('Include',   s:yellow, s:none, 'NONE')
call s:hi('Define',    s:yellow, s:none, 'NONE')
call s:hi('PreCondit', s:yellow, s:none, 'NONE')

call s:hi('cIncluded', s:bright_cyan, s:none, 'italic')

call s:hi('Function', s:magenta, s:none, 'NONE')
call s:hi('Macro', s:bright_red, s:none, 'NONE')

" Make folds blend in so that the status bar and splits are easier to identify
call s:hi('Folded', s:none, s:none, 'italic')
call s:hi('LineNr', s:white, s:darkest_gray, 'NONE')
call s:hi('CursorLineNr', s:darkest_gray, s:bright_black, 'NONE')
call s:hi('StatusLineNC', s:dark_gray, s:darkest_gray, 'NONE')

call s:hi('Pmenu', s:bright_white, s:darker_gray, 'NONE')
call s:hi('PmenuSel', s:bright_white, s:magenta, 'bold')

call s:hi('DiffDelete', s:none, s:red, 'none')
call s:hi('DiffAdd', s:none, s:green, 'none')
call s:hi('DiffChange', s:none, s:cyan, 'none')
call s:hi('DiffText', s:none, s:bright_yellow, 'none')

if has('spell')
    call s:hi('SpellCap', s:none, s:magenta, 'underline')
    call s:hi('SpellBad', s:none, s:red, 'underline')
    call s:hi('SpellLocal', s:none, s:yellow, 'underline')
    call s:hi('SpellRare', s:none, s:cyan, 'underline')
endif
if has('terminal')
    call s:hi('Terminal', s:bright_white, s:dark_black, 'NONE')
endif

" statuslime colors
call s:hi('LimeNormal',       s:dark_black,    s:white,   'bold')
call s:hi('LimeVisual',       s:dark_black,    s:blue,    'bold')
call s:hi('LimeInsert',       s:dark_black,    s:bright_yellow,  'bold')
call s:hi('LimeReplace',      s:dark_black,    s:yellow,  'bold')
call s:hi('LimeTerminal',     s:dark_black,    s:green,   'bold')
call s:hi('LimeCommand',      s:dark_black,    s:magenta, 'bold')
call s:hi('LimeShell',        s:dark_black,    s:cyan,    'bold')
call s:hi('LimeOther',        s:dark_black,    s:red,     'bold')
call s:hi('LimeFile',         s:bright_white,  s:dark_gray,  'NONE')
call s:hi('LimeError',        s:bright_red,    s:darkest_gray,  'bold')
call s:hi('LimeRuler',        s:bright_white,  s:darker_gray,  'NONE')
call s:hi('LimeInactiveBar',  s:dark_black,    s:darker_gray,  'NONE')
call s:hi('LimeInactiveMode', s:dark_black,    s:dark_gray,  'NONE')
call s:hi('LimeLeft',         s:yellow, s:darkest_gray,  'NONE')
call s:hi('LimeRight',        s:bright_yellow, s:darkest_gray,  'NONE')

" buftabline colors
call s:hi('BufTabLineCurrent', s:dark_black,   s:white,        'bold')
call s:hi('BufTabLineActive',  s:red,          s:white,        'NONE')
call s:hi('BufTabLineHidden',  s:lighter_gray, s:white,        'NONE')
call s:hi('BufTabLineFill',    s:black,        s:bright_black, 'NONE')

" vim-lsp colors
call s:hi('LspErrorHighlight',       s:red,    s:none, 'underline')
call s:hi('LspWarningHighlight',     s:yellow, s:none, 'underline')
call s:hi('LspInformationHighlight', s:blue,   s:none, 'underline')
call s:hi('LspHintHighlight',        s:green,  s:none, 'underline')

" conflict-marker.vim
call s:hi('ConflictMarkerBegin',     s:bright_cyan, s:none,         'bold')
call s:hi('ConflictMarkerOurs',      s:none,        s:darkest_gray, 'NONE')
call s:hi('ConflictMarkerSeparator', s:cyan,        s:none,         'bold')
call s:hi('ConflictMarkerTheirs',    s:none,        s:dark_black,   'NONE')
call s:hi('ConflictMarkerEnd',       s:bright_cyan, s:none,         'bold')

" }}}

" Maps {{{

if has("terminal")
    " Navigate out of terminal mode more easily
    tnoremap <esc> <c-\><c-n>
    tnoremap <c-w> <c-\><c-n><c-w>
endif
" Quick reload of vimrc
nnoremap <leader>V :source $MYVIMRC<cr>
" Clear search with <C-L>
nnoremap <c-l> :noh<cr><c-l>

nnoremap ` <c-w>
nnoremap <c-w>` `

nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)

noremap <silent><leader>? :call quickmenu#toggle(g:plugin_help_menu)<cr>
noremap <silent><leader>g :GitMessenger<cr>

nmap ga <Plug>(EasyAlign)
vmap <Enter> <Plug>(EasyAlign)

nmap <buffer>]x <Plug>(conflict-marker-next-hunk)
nmap <buffer>[x <Plug>(conflict-marker-prev-hunk)

" }}}

" Plugin Configuration {{{

let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_list_hide = netrw_gitignore#Hide()

let g:indentLine_char_list = ['|', '¦', '┆', '┊']
let g:indentLine_setColors = 0

let g:buftabline_indicators = 1
let g:buftabline_numbers = 0

let g:git_messenger_include_diff = v:true
let g:git_messenger_max_popup_height = 8

let g:conflict_marker_enable_mappings = 0

let g:quickmenu_options = "H"
try
    " Populate quickmenu with installed plugins with helpfiles
    call quickmenu#current(g:plugin_help_menu)
    call quickmenu#reset()
    call quickmenu#header('plugin help')
    for p in g:plugin_help_list
        let short = substitute(
                \ substitute(
                    \ split(p, '/')[1],
                \ 'vim-', '', 'g'),
            \ '.vim', '', 'g')
        call quickmenu#append(short, 'h '.short.'.txt', '')
    endfor
catch
    echom 'quickmenu could not be initialized'
endtry
" }}}

" Emacs style scrolling where the view re-centers on cursor
func! CenterOnScroll()
    if exists('b:last_topline') == v:false
        let b:last_topline = 1
    endif
    if exists('b:last_curline') == v:false
        let b:last_curline = 1
    endif
    let l:topline = winsaveview()['topline']
    let l:curline = line('.')

    if l:topline != b:last_topline && l:curline != b:last_curline
        norm zz
    endif
    let b:last_topline = l:topline
    let b:last_curline = l:curline
endfunc
au CursorMoved,CursorMovedI * call CenterOnScroll()

" Useful for debugging syntax highlighting
func! HiAtCur()
    let l:name = ''
    for id in synstack(line('.'), col('.'))
        let l:name = synIDattr(id, 'name')
        echo l:name
    endfor
    if l:name isnot ''
        exec 'hi '.l:name
    endif
endfunc
nmap <leader>c :call HiAtCur()<cr>

" For now, only enable LSP on neovim. Will configure for vim8 later.
if has('nvim') == 0
    finish
endif

set termguicolors

let s:lsp_map = {}

if executable('clangd')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'clangd',
        \ 'cmd': {server_info->['clangd']},
        \ 'whitelist': ['cpp', 'c']
        \ })
    let s:lsp_map['c']   = 'clangd'
    let s:lsp_map['cpp'] = 'clangd'
endif

if executable('pyls')
    " pip install python-language-server
    au User lsp_setup call lsp#register_server({
        \ 'name': 'pyls',
        \ 'cmd': {server_info->['pyls']},
        \ 'whitelist': ['python'],
        \ })
    let s:lsp_map['python'] = 'pyls'
endif

if executable('bash-language-server')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'bash-language-server',
        \ 'cmd': {server_info->['bash-language-server']},
        \ 'whitelist': ['sh'],
        \ })
    let s:lsp_map['sh'] = 'bls'
endif

if executable('docker-langserver')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'docker-langserver',
        \ 'cmd': {server_info->['docker-langserver']},
        \ 'whitelist': ['Dockerfile'],
        \ })
    let s:lsp_map['Dockerfile'] = 'dls'
endif

let g:lsp_preview_doubletap = 0
let g:lsp_signs_enabled = 1
let g:lsp_virtual_text_enabled = 1

" The preview window does not update while typing / moving cursor
" inside signature help. This function should continue to show
" the help while the arguments are being entered.
function! s:sig()
    " TODO
endfunc

function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    nmap <buffer> <leader>D <plug>(lsp-peek-definition)
    nmap <buffer> <leader>d <plug>(lsp-peek-declaration)
    nmap <buffer> <leader>R <plug>(lsp-rename)
    nmap <buffer> <leader>s <plug>(lsp-signature-help)
    nmap <buffer> <leader>r <plug>(lsp-references)
    nmap <buffer> <leader>h <plug>(lsp-hover)
    imap <c-space> <Plug>(asyncomplete_force_refresh)
    inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
    inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
    inoremap <expr> <cr> pumvisible() ? "\<C-y>\<cr>" : "\<cr>"
    autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
    let b:statuslime_right = s:lsp_map[&ft]
endfunction

augroup lsp_install
    au!
    " call s:on_lsp_buffer_enabled only for languages that has the server registered.
    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END


